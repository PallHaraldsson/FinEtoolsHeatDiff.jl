<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · FinEtoolsHeatDiff.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FinEtoolsHeatDiff.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../guide/guide.html">Guide</a></li><li><span class="toctext">Types and Functions</span><ul><li><a class="toctext" href="types.html">Types</a></li><li class="current"><a class="toctext" href="functions.html">Functions</a><ul class="internal"><li><a class="toctext" href="#FEM-machines-1">FEM machines</a></li><li><a class="toctext" href="#Algorithms-1">Algorithms</a></li><li><a class="toctext" href="#Material-models-1">Material models</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Types and Functions</li><li><a href="functions.html">Functions</a></li></ul><a class="edit-page" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/master/docs/src/man/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><h2><a class="nav-anchor" id="FEM-machines-1" href="#FEM-machines-1">FEM machines</a></h2><h3><a class="nav-anchor" id="Heat-diffusion-1" href="#Heat-diffusion-1">Heat diffusion</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FEMMHeatDiff,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FEMMHeatDiff,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any,Any}} where F&lt;:Function where T&lt;:Number" href="#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FEMMHeatDiff,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FEMMHeatDiff,NodalField{Float64},NodalField{T},NodalField{Float64},Array{Int64,1},F,Any,Any}} where F&lt;:Function where T&lt;:Number"><code>FinEtools.FEMMBaseModule.inspectintegpoints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inspectintegpoints(self::FEMMHeatDiff, geom::NodalField{FFlt}, u::NodalField{T}, temp::NodalField{FFlt}, felist::FIntVec, inspector::F, idat, quantity=:heatflux; context...) where {F&lt;:Function}</code></pre><p>Inspect integration point quantities.</p><p><strong>Inputs</strong></p><ul><li><code>geom</code> - reference geometry field</li><li><code>u</code> - displacement field (ignored)</li><li><code>temp</code> - temperature field</li><li><code>felist</code> - indexes of the finite elements that are to be inspected: The fes to be included are: <code>fes[felist]</code>.</li><li><code>context</code>    - structure: see the update!() method of the material.</li><li><code>inspector</code> - function with the signature       <code>idat = inspector(idat, j, conn, x, out, loc);</code>  where   <code>idat</code> - a structure or an array that the inspector may          use to maintain some state,  for instance minimum or maximum of          stress, <code>j</code> is the element number, <code>conn</code> is the element connectivity,          <code>out</code> is the output of the update!() method,  <code>loc</code> is the location          of the integration point in the <em>reference</em> configuration.</li></ul><p><strong>Return</strong></p><p>The updated inspector data is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/f94009067f97105a2b2cf0638cd89b3805665157/src/FEMMHeatDiffModule.jl#L182-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsHeatDiff.FEMMHeatDiffModule.conductivity-Union{Tuple{A}, Tuple{FEMMHeatDiff,A,NodalField{Float64},NodalField{Float64}}} where A&lt;:AbstractSysmatAssembler" href="#FinEtoolsHeatDiff.FEMMHeatDiffModule.conductivity-Union{Tuple{A}, Tuple{FEMMHeatDiff,A,NodalField{Float64},NodalField{Float64}}} where A&lt;:AbstractSysmatAssembler"><code>FinEtoolsHeatDiff.FEMMHeatDiffModule.conductivity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">conductivity(self::FEMMHeatDiff,
  assembler::A, geom::NodalField{FFlt},
  temp::NodalField{FFlt}) where {A&lt;:AbstractSysmatAssembler}</code></pre><p>Compute the conductivity matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/f94009067f97105a2b2cf0638cd89b3805665157/src/FEMMHeatDiffModule.jl#L69-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsHeatDiff.FEMMHeatDiffModule.energy-Tuple{FEMMHeatDiff,NodalField{Float64},NodalField{Float64}}" href="#FinEtoolsHeatDiff.FEMMHeatDiffModule.energy-Tuple{FEMMHeatDiff,NodalField{Float64},NodalField{Float64}}"><code>FinEtoolsHeatDiff.FEMMHeatDiffModule.energy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">energy(self::FEMMHeatDiff, geom::NodalField{FFlt},  temp::NodalField{FFlt})</code></pre><p>Compute the &quot;energy&quot; integral over the interior domain.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/f94009067f97105a2b2cf0638cd89b3805665157/src/FEMMHeatDiffModule.jl#L150-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsHeatDiff.FEMMHeatDiffModule.nzebcloadsconductivity-Union{Tuple{A}, Tuple{FEMMHeatDiff,A,NodalField{Float64},NodalField{Float64}}} where A&lt;:AbstractSysvecAssembler" href="#FinEtoolsHeatDiff.FEMMHeatDiffModule.nzebcloadsconductivity-Union{Tuple{A}, Tuple{FEMMHeatDiff,A,NodalField{Float64},NodalField{Float64}}} where A&lt;:AbstractSysvecAssembler"><code>FinEtoolsHeatDiff.FEMMHeatDiffModule.nzebcloadsconductivity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">nzebcloadsconductivity(self::FEMMHeatDiff,
  assembler::A,  geom::NodalField{FFlt},
  temp::NodalField{FFlt}) where {A&lt;:AbstractSysvecAssembler}</code></pre><p>Compute load vector for nonzero EBC of prescribed temperature.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/f94009067f97105a2b2cf0638cd89b3805665157/src/FEMMHeatDiffModule.jl#L107-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsHeatDiff.FEMMHeatDiffSurfModule.nzebcsurfacetransferloads-Union{Tuple{A}, Tuple{FEMMHeatDiffSurf,A,NodalField{Float64},NodalField{Float64}}} where A&lt;:AbstractSysvecAssembler" href="#FinEtoolsHeatDiff.FEMMHeatDiffSurfModule.nzebcsurfacetransferloads-Union{Tuple{A}, Tuple{FEMMHeatDiffSurf,A,NodalField{Float64},NodalField{Float64}}} where A&lt;:AbstractSysvecAssembler"><code>FinEtoolsHeatDiff.FEMMHeatDiffSurfModule.nzebcsurfacetransferloads</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">nzebcsurfacetransferloads(self::FEMMHeatDiffSurf, assembler::A,
  geom::NodalField{FFlt}, temp::NodalField{FFlt}) where {A&lt;:AbstractSysvecAssembler}</code></pre><p>Compute load vector for nonzero EBC for fixed temperature.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/f94009067f97105a2b2cf0638cd89b3805665157/src/FEMMHeatDiffSurfModule.jl#L127-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsHeatDiff.FEMMHeatDiffSurfModule.surfacetransfer-Union{Tuple{A}, Tuple{FEMMHeatDiffSurf,A,NodalField{Float64},NodalField{Float64}}} where A&lt;:AbstractSysmatAssembler" href="#FinEtoolsHeatDiff.FEMMHeatDiffSurfModule.surfacetransfer-Union{Tuple{A}, Tuple{FEMMHeatDiffSurf,A,NodalField{Float64},NodalField{Float64}}} where A&lt;:AbstractSysmatAssembler"><code>FinEtoolsHeatDiff.FEMMHeatDiffSurfModule.surfacetransfer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">surfacetransfer(self::FEMMHeatDiffSurf,  assembler::A,
  geom::NodalField{FFlt}, temp::NodalField{FFlt}) where {A&lt;:AbstractSysmatAssembler}</code></pre><p>Compute the surface heat transfer matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/f94009067f97105a2b2cf0638cd89b3805665157/src/FEMMHeatDiffSurfModule.jl#L30-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsHeatDiff.FEMMHeatDiffSurfModule.surfacetransferloads-Union{Tuple{A}, Tuple{FEMMHeatDiffSurf,A,NodalField{Float64},NodalField{Float64},NodalField{Float64}}} where A&lt;:AbstractSysvecAssembler" href="#FinEtoolsHeatDiff.FEMMHeatDiffSurfModule.surfacetransferloads-Union{Tuple{A}, Tuple{FEMMHeatDiffSurf,A,NodalField{Float64},NodalField{Float64},NodalField{Float64}}} where A&lt;:AbstractSysvecAssembler"><code>FinEtoolsHeatDiff.FEMMHeatDiffSurfModule.surfacetransferloads</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">surfacetransferloads(self::FEMMHeatDiffSurf,  assembler::A,
  geom::NodalField{FFlt}, temp::NodalField{FFlt},
  ambtemp::NodalField{FFlt}) where {A&lt;:AbstractSysvecAssembler}</code></pre><p>Compute the load vector corresponding to surface heat transfer.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/f94009067f97105a2b2cf0638cd89b3805665157/src/FEMMHeatDiffSurfModule.jl#L74-L80">source</a></section><h2><a class="nav-anchor" id="Algorithms-1" href="#Algorithms-1">Algorithms</a></h2><h3><a class="nav-anchor" id="Heat-conduction-1" href="#Heat-conduction-1">Heat conduction</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsHeatDiff.AlgoHeatDiffModule.steadystate-Tuple{Dict{String,Any}}" href="#FinEtoolsHeatDiff.AlgoHeatDiffModule.steadystate-Tuple{Dict{String,Any}}"><code>FinEtoolsHeatDiff.AlgoHeatDiffModule.steadystate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">steadystate(modeldata::FDataDict)</code></pre><p>Steady-state heat conduction solver.</p><p><strong>Argument</strong></p><p><code>modeldata</code> = dictionary with items</p><ul><li><code>&quot;fens&quot;</code>  = finite element node set</li><li><code>&quot;regions&quot;</code>  = array of region dictionaries</li><li><code>&quot;essential_bcs&quot;</code> = array of essential boundary condition dictionaries</li><li><code>&quot;convection_bcs&quot;</code> = array of convection boundary condition dictionaries</li><li><code>&quot;flux_bcs&quot;</code> = array of flux boundary condition dictionaries</li></ul><p>For each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains items:</p><ul><li><code>&quot;femm&quot;</code> = finite element mmodel machine (mandatory);</li><li><code>&quot;Q&quot;</code> = material internal heat generation rate (optional; default  0.0)</li></ul><p>For essential boundary conditions (optional) each dictionary would hold</p><ul><li><code>&quot;temperature&quot;</code> = fixed (prescribed) temperature (scalar),  or         a function with signature             function T = f(x)         If not given, zero temperatures assumed.</li><li><code>&quot;node_list&quot;</code> = list of nodes on the boundary to which the condition applies         (mandatory)</li></ul><p>For convection boundary conditions (optional) each dictionary may hold</p><ul><li><code>&quot;femm&quot;</code> = finite element mmodel machine (mandatory);</li><li><code>&quot;ambient_temperature&quot;</code> = fixed (prescribed) ambient temperature (scalar)     If not given, zero temperatures assumed.</li></ul><p>For flux boundary conditions (optional) each dictionary would hold</p><ul><li><code>&quot;femm&quot;</code> = finite element mmodel machine (mandatory);</li><li><code>&quot;normal_flux&quot;</code> = normal component of the flux through the boundary (scalar)     Positive  when outgoing.</li></ul><p><strong>Output</strong></p><p><code>modeldata</code>= the dictionary on input is augmented with</p><ul><li><code>&quot;geom&quot;</code> = the nodal field that is the geometry</li><li><code>&quot;temp&quot;</code> = the nodal field that is the computed temperature</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/f94009067f97105a2b2cf0638cd89b3805665157/src/AlgoHeatDiffModule.jl#L20-L64">source</a></section><h2><a class="nav-anchor" id="Material-models-1" href="#Material-models-1">Material models</a></h2><h3><a class="nav-anchor" id="Material-models-for-heat-diffusion-1" href="#Material-models-for-heat-diffusion-1">Material models for heat diffusion</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsHeatDiff.MatHeatDiffModule.tangentmoduli!" href="#FinEtoolsHeatDiff.MatHeatDiffModule.tangentmoduli!"><code>FinEtoolsHeatDiff.MatHeatDiffModule.tangentmoduli!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tangentmoduli!(self::MatHeatDiff, kappabar::FFltMat, t::FFlt, dt::FFlt, loc::FFltMat, label::FInt)</code></pre><p>Calculate the thermal conductivity matrix.</p><ul><li><code>kappabar</code> = matrix of thermal conductivity (tangent moduli) in material coordinate system, supplied as a buffer and overwritten.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/f94009067f97105a2b2cf0638cd89b3805665157/src/MatHeatDiffModule.jl#L38-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsHeatDiff.MatHeatDiffModule.update!" href="#FinEtoolsHeatDiff.MatHeatDiffModule.update!"><code>FinEtoolsHeatDiff.MatHeatDiffModule.update!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update!(self::MatHeatDiff, heatflux::FFltVec, output::FFltVec, gradT::FFltVec, t::FFlt= 0.0, dt::FFlt= 0.0,  loc::FFltMat=FFltMat[], label::FInt=0, quantity=:nothing)</code></pre><p>Update material state.</p><ul><li><code>strain</code> = strain vector,</li></ul><p><code>thstrain</code> = thermal strain vector,</p><ul><li><code>t</code> = current time,</li><li><code>dt</code> = current time step,</li><li><code>loc</code> = location of the quadrature point in global Cartesian coordinates,</li><li><code>label</code> = label of the finite element in which the quadrature point is located.</li></ul><p>Output:</p><ul><li><code>heatflux</code> = heat flux vector, allocated by the caller with a size of the embedding space. The components of the heat flux vector are calculated and stored in the <code>heatflux</code> vector.</li><li><code>output</code> =  array which is (if necessary) allocated  in an appropriate size, filled with the output quantity, and returned.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/f94009067f97105a2b2cf0638cd89b3805665157/src/MatHeatDiffModule.jl#L51-L69">source</a></section><footer><hr/><a class="previous" href="types.html"><span class="direction">Previous</span><span class="title">Types</span></a></footer></article></body></html>
